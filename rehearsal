#!/bin/sh
# vim: set filetype=tcl : \
exec expect -f "$0" -- ${1+"$@"}

proc shift {var n} {
    upvar $var list
    set list [lrange $list $n end]
}

proc debug {msg} {
    global debug
    if {$debug} {
        puts "# debug: $msg"
    }
}

proc print_tap {n result desc directive diag} {
    if {$directive == ""} {
        puts "$result $n $desc"
    } else {
        puts "$result $n $desc # $directive"
    }
    foreach diag_line $diag {
        puts "# $diag_line"
    }
}

proc expect_prompt {} {
    uplevel 1 {
        expect -re $prompt {
        } timeout {
            expect -re .*
            error "timeout: prompt /${prompt}/ expected but got <$expect_out(buffer)>"
        }
        return $expect_out(buffer)
    }
}

proc send_lines {} {
    uplevel 1 {
        foreach input_line $input_lines {
            debug "sending: $input_line"
            send $input_line
            send "\r"
            # eat echo back
            debug "expect: $input_line"
            expect -ex "$input_line\r\n" {} timeout {error "no echo back <$input_line>"}
        }
    }
}

proc run_test {} {
    uplevel 1 {
        debug "test: $test"
        set desc [dict get $test desc]
        set steps [dict get $test steps]
        foreach {input output} $steps {
            debug "input: $input"
            debug "output: $output"
            set input_lines [split $input "\n"]
            send_lines

            set state normal
            set diag [list]
            while {[llength $output] >= 2} {
                # peek first two elements, options and line, from output
                lassign $output opts output_line
                if {$opts == "snip"} {
                    set state snip
                    shift output 2
                    continue
                }
                set line_match false
                expect \
                    -re {.*?\r\n} {
                        set line [string trimright $expect_out(buffer) "\r\n"]
                        debug "actual_line: <$line>"
                        debug "expected_line: <$output_line>"
                        if {$line == $output_line} {
                            debug "match"
                            set line_match true
                            set state normal
                            # eat first two elements if matched
                            shift output 2
                        } else {
                            debug "unmatch"
                            if {$state == "snip"} {
                                exp_continue
                            } else {
                                lappend diag "expected: $output_line"
                                lappend diag "actual: [string trimright $expect_out(buffer) "\r\n"]"
                                break
                            }
                        }
                    } \
                    timeout break
            }
            if {!$line_match} break
        }
        # ensure the prompt is there before moving to the next test
        set until_prompt [expect_prompt]
        regexp "^(.*)$prompt\$" $until_prompt match trailing
        if {$line_match} {
            if {$trailing != "" && $state != "snip"} {
                foreach output_line [split [string trimright $trailing "\r\n"]] {
                    lappend diag "unexpected trailing line: $output_line"
                }
                set result "not ok"
            } else {
                set result "ok"
            }
        } else {
            # if $line_match is false, the while loop should have exitted with
            # break because of an unmatched line or timeout.
            # In the latter case, $diag should be empty
            if {[llength $diag] == 0} {
                if {$trailing == $output_line} {
                    debug "match'"
                    # eat first two elements if matched
                    shift output 2
                    if {[llength $output] > 0} {
                        lassign $output opts output_line
                        lappend diag "expected: $output_line"
                        lappend diag "actual: "
                        set result "not ok"
                    } else {
                        set result "ok"
                    }
                } else {
                    lassign $output opts output_line
                    lappend diag "expected: $output_line"
                    lappend diag "actual: $trailing"
                    set result "not ok"
                }
            } else {
                set result "not ok"
            }
        }
        return [list $result $desc "" $diag]
    }
}

proc run_suite {suite} {
    global results
    set command_line [dict get $suite command_line]
    set prompt [dict get $suite prompt]
    set tests [dict get $suite tests]
    set num_tests [llength $tests]
    if {$num_tests == 0} return

    puts "1..$num_tests"
    set n 0
    if {[catch {
            debug "spawning $command_line"
            spawn {*}$command_line
            expect_prompt

            foreach test $tests {
                incr n
                debug "running $n"
                lassign [run_test] result desc directive diag
                lappend results [dict create \
                    num $n \
                    result $result \
                    desc $desc \
                    diag $diag]
                print_tap $n $result $desc $directive $diag
            }

            send "\004"
            expect eof
        } message]} {
        lappend results [dict create \
            result "Bail out!" \
            num $n \
            desc "?" \
            diag [split $message]]
        puts "Bail out!"
        puts $message
    }
}

proc suite {suite} {
    run_suite $suite
}

proc escape_xml {s} {
    return [string map [list "\"" {&quot;} ' {&apos;} < {&lt;} > {&gt;} & {&amp;}] $s]
}

proc write_junit {} {
    global results
    global junit_file
    set f [open $junit_file w]
    fconfigure $f -encoding utf-8
    puts $f {<?xml version="1.0" ?>}
    puts $f "<testsuite name='rehearsal' tests='[llength $results]'>"
    foreach result $results {
        puts $f "<testcase name='[escape_xml "[dict get $result num] [dict get $result desc]"]'>"
        if {[dict get $result result] == "not ok"} {
            puts -nonewline $f {<failure>}
            foreach line [dict get $result diag] {
                puts $f [escape_xml $line]
            }
            puts $f {</failure>}
        } elseif {[dict get $result result] == "Bail out!"} {
            puts -nonewline $f {<error>}
            foreach line [dict get $result diag] {
                puts $f [escape_xml $line]
            }
            puts $f {</error>}
        }
        puts $f {</testcase>}
    }
    puts $f {</testsuite>}
    close $f
}

# starting point

# globals
set debug 0
set log_file "" 
set junit_file ""
set results [list]
set md 0
set command_line ""
set ps1 ""
set ps2 ""

# parse argv
while {true} {
    lassign $argv first
    if {![string match {-*} $first]} break
    shift argv 1
    if {$first == "--"} {
        break
    } elseif {$first == "-v"} {
        set debug 1
    } elseif {$first == "-log"} {
        lassign $argv log_file
        shift argv 1
    } elseif {$first == "-junit"} {
        lassign $argv junit_file
        shift argv 1
    } elseif {$first == "-command"} {
        lassign $argv command_line
        shift argv 1
    } elseif {$first == "-ps1"} {
        lassign $argv ps1
        shift argv 1
    } elseif {$first == "-ps2"} {
        lassign $argv ps2
        shift argv 1
    } elseif {$first == "-md"} {
        set md 1
    }
}

log_user 0
if {$log_file != ""} {
    log_file -a $log_file
}

source [lindex $argv 0]

if {$junit_file != ""} {
    write_junit
}
