#!/bin/sh
# vim: set filetype=tcl : \
exec expect -f "$0" -- ${1+"$@"}

namespace eval testcase {
    # operations for 'testcase' dict type

    proc new {} {
        return [dict create desc "" steps [list] input [list] output [list]]
    }

    proc set_desc {test_var desc} {
        upvar $test_var test
        dict set test desc $heading
    }

    proc append_input {test_var line} {
        upvar $test_var test
        dict lappend test input $line
    }

    proc append_output {test_var line} {
        upvar $test_var test
        dict lappend test output -ex $line
    }

    proc append_snip {test_var} {
        upvar $test_var test
        dict lappend test output snip {}
    }

    proc carry_step {test_var} {
        upvar $test_var test

        if {[llength [dict get $test input]] > 0} {
            dict lappend test steps \
                [dict get $test input] \
                [dict get $test output]
            dict set test input [list]
            dict set test output [list]
        }
    }

    proc carry {tests_var test_var} {
        upvar $tests_var tests
        upvar $test_var test

        if {[llength [dict get $test steps]] > 0} {
            lappend tests $test
            dict set test steps [list]
        }
    }
}

namespace eval markdown {
    # markdown parser

    proc parse {channel command_line} {
        global ps1

        set state md_default
        set prev ""
        set tests [list]
        set test [testcase::new]
        while {![eof $channel]} {
            gets $channel line
            debug "state: $state, line: $line"
            set state [{*}$state $line]
            set prev $line
        }
        testcase::carry tests test
        set suite [dict create command_line $command_line prompt $ps1 tests $tests]
        debug "suite: $suite"
        return $suite
    }

    proc md_default {line} {
        global ps1
        upvar tests tests
        upvar test test

        if {[regexp {^#{1,6}\s*(.*)#{0,6}\s*$} $line match heading]} {
            testcase::carry tests test
            dict set test desc $heading
            return md_default
        } elseif {[string match "`````*" $line]} {
            return [list md_in_fence_ps1 5]
        } elseif {[string match "````*" $line]} {
            return [list md_in_fence_ps1 4]
        } elseif {[string match "```*" $line]} {
            return [list md_in_fence_ps1 3]
        } elseif {[regexp {^    (.*)} $line match line]} {
            if {[regexp "^${ps1}(.*)\$" $line match line]} {
                testcase::append_input test $line
                return md_indent_ps2
            } else {
                return md_indent_skip
            }
        } else {
            return md_default
        }
    }

    proc md_in_fence_ps1 {num_ticks line} {
        global ps1
        upvar tests tests
        upvar test test

        set ticks [string repeat "`" $num_ticks]
        if {$line == $ticks} {
            testcase::carry_step test
            return md_default
        } elseif {[regexp "^${ps1}(.*)\$" $line match line]} {
            testcase::append_input test $line
            return [list md_in_fence_ps2 $num_ticks]
        } else {
            return [list md_in_fence_skip $num_ticks]
        }
    }

    proc md_in_fence_ps2 {num_ticks line} {
        global ps2
        upvar tests tests
        upvar test test

        set ticks [string repeat "`" $num_ticks]
        if {$line == $ticks} {
            testcase::carry_step test
            return md_default
        } elseif {[regexp "^${ps2}(.*)\$" $line match line]} {
            testcase::append_input test $line
            return [list md_in_fence_ps2 $num_ticks]
        } elseif {$line == "..."} {
            testcase::append_snip test
            return [list md_in_fence_output $num_ticks]
        } else {
            testcase::append_output test $line
            return [list md_in_fence_output $num_ticks]
        }
    }

    proc md_in_fence_output {num_ticks line} {
        upvar tests tests
        upvar test test

        set ticks [string repeat "`" $num_ticks]
        if {$line == $ticks} {
            testcase::carry_step test
            return md_default
        } elseif {$line == "..."} {
            testcase::append_snip test
            return [list md_in_fence_output $num_ticks]
        } else {
            testcase::append_output test $line
            return [list md_in_fence_output $num_ticks]
        }
    }

    proc md_in_fence_skip {num_ticks line} {
        upvar tests tests
        upvar test test

        set ticks [string repeat "`" $num_ticks]
        if {$line == $ticks} {
            return md_default
        } else {
            return [list md_in_fence_skip $num_ticks]
        }
    }

    proc md_indent_ps2 {line} {
        global ps2
        upvar tests tests
        upvar test test

        if {[regexp {^    (.*)} $line match line]} {
            if {[regexp "^${ps2}(.*)\$" $line match line]} {
                testcase::append_input test $line
                return md_indent_ps2
            } elseif {$line == "    ..."} {
                testcase::append_snip test
                return md_indent_output
            } else {
                testcase::append_output test $line
                return md_indent_output
            }
        } else {
            testcase::carry_step test
            return [md_default $line]
        }
    }

    proc md_indent_output {line} {
        upvar tests tests
        upvar test test

        if {[regexp {^    (.*)} $line match line]} {
            testcase::append_output test $line
            return md_indent_output
        } elseif {$line == "    ..."} {
            testcase::append_snip test
            return [md_default $line]
        } else {
            testcase::carry_step test
            return [md_default $line]
        }
    }

    proc md_indent_skip {line} {
        upvar tests tests
        upvar test test

        if {[regexp {^    (.*)} $line]} {
            return md_indent_skip
        } else {
            return [md_default $line]
        }
    }
}

proc shift {var n} {
    upvar $var list
    set list [lrange $list $n end]
}

proc debug {msg} {
    global debug
    if {$debug} {
        puts "# debug: $msg"
    }
}

proc print_tap {n result desc directive diag} {
    if {$directive == ""} {
        puts "$result $n $desc"
    } else {
        puts "$result $n $desc # $directive"
    }
    foreach diag_line $diag {
        puts "# $diag_line"
    }
}

proc expect_prompt {} {
    uplevel 1 {
        expect -re $prompt {
        } timeout {
            expect -re .*
            error "timeout: prompt /${prompt}/ expected but got <$expect_out(buffer)>"
        }
        return $expect_out(buffer)
    }
}

proc send_lines {} {
    uplevel 1 {
        foreach input_line $input_lines {
            debug "sending: $input_line"
            send $input_line
            send "\r"
            # eat echo back
            debug "expect: $input_line"
            expect -ex "$input_line\r\n" {} timeout {error "no echo back <$input_line>"}
        }
    }
}

proc run_test {} {
    uplevel 1 {
        debug "test: $test"
        set desc [dict get $test desc]
        set steps [dict get $test steps]
        foreach {input output} $steps {
            debug "input: $input"
            debug "output: $output"
            set input_lines $input
            send_lines

            set state normal
            set diag [list]
            while {[llength $output] >= 2} {
                # peek first two elements, options and line, from output
                lassign $output opts output_line
                if {$opts == "snip"} {
                    set state snip
                    shift output 2
                    continue
                }
                set line_match false
                expect \
                    -re {.*?\r\n} {
                        set line [string trimright $expect_out(buffer) "\r\n"]
                        debug "actual_line: <$line>"
                        debug "expected_line: <$output_line>"
                        if {$line == $output_line} {
                            debug "match"
                            set line_match true
                            set state normal
                            # eat first two elements if matched
                            shift output 2
                        } else {
                            debug "unmatch"
                            if {$state == "snip"} {
                                exp_continue
                            } else {
                                lappend diag "expected: $output_line"
                                lappend diag "actual: [string trimright $expect_out(buffer) "\r\n"]"
                                break
                            }
                        }
                    } \
                    timeout break
            }
            if {!$line_match} break
        }
        # ensure the prompt is there before moving to the next test
        set until_prompt [expect_prompt]
        regexp "^(.*)$prompt\$" $until_prompt match trailing
        if {$line_match} {
            set trailing_lines [list]
            foreach output_line [split [string trimright $trailing "\r\n"]] {
                lappend trailing_lines $output_line
            }
            if {[llength $trailing_lines] != 0 && $state != "snip"} {
                foreach trailing_line $trailing_lines {
                    lappend diag "unexpected trailing line: $trailing_line"
                }
                set result "not ok"
            } else {
                set result "ok"
            }
        } else {
            # if $line_match is false, the while loop should have exitted with
            # break because of an unmatched line or timeout.
            # In the latter case, $diag should be empty
            if {[llength $diag] == 0} {
                if {$trailing == $output_line} {
                    debug "match'"
                    # eat first two elements if matched
                    shift output 2
                    if {[llength $output] > 0} {
                        lassign $output opts output_line
                        lappend diag "expected: $output_line"
                        lappend diag "actual: "
                        set result "not ok"
                    } else {
                        set result "ok"
                    }
                } else {
                    lassign $output opts output_line
                    lappend diag "expected: $output_line"
                    lappend diag "actual: $trailing"
                    set result "not ok"
                }
            } else {
                set result "not ok"
            }
        }
        return [list $result $desc "" $diag]
    }
}

proc run_suite {suite} {
    global results
    set command_line [dict get $suite command_line]
    set prompt [dict get $suite prompt]
    set tests [dict get $suite tests]
    set num_tests [llength $tests]
    if {$num_tests == 0} return

    puts "1..$num_tests"
    set n 0
    if {[catch {
            debug "spawning $command_line"
            spawn {*}$command_line
            expect_prompt

            foreach test $tests {
                incr n
                debug "running $n"
                lassign [run_test] result desc directive diag
                lappend results [dict create \
                    num $n \
                    result $result \
                    desc $desc \
                    diag $diag]
                print_tap $n $result $desc $directive $diag
            }

            send "\004"
            expect eof
        } message]} {
        lappend results [dict create \
            result "Bail out!" \
            num $n \
            desc "?" \
            diag [split $message]]
        puts "Bail out!"
        puts $message
    }
}

proc suite {suite} {
    run_suite $suite
}

proc escape_xml {s} {
    return [string map [list "\"" {&quot;} ' {&apos;} < {&lt;} > {&gt;} & {&amp;}] $s]
}

proc write_junit {} {
    global results
    global junit_file
    set f [open $junit_file w]
    fconfigure $f -encoding utf-8
    puts $f {<?xml version="1.0" ?>}
    puts $f "<testsuite name='rehearsal' tests='[llength $results]'>"
    foreach result $results {
        puts $f "<testcase name='[escape_xml "[dict get $result num] [dict get $result desc]"]'>"
        if {[dict get $result result] == "not ok"} {
            puts -nonewline $f {<failure>}
            foreach line [dict get $result diag] {
                puts $f [escape_xml $line]
            }
            puts $f {</failure>}
        } elseif {[dict get $result result] == "Bail out!"} {
            puts -nonewline $f {<error>}
            foreach line [dict get $result diag] {
                puts $f [escape_xml $line]
            }
            puts $f {</error>}
        }
        puts $f {</testcase>}
    }
    puts $f {</testsuite>}
    close $f
}

# starting point

# globals
set debug 0
set log_file "" 
set junit_file ""
set results [list]
set command_line {sh}
set ps1 {\$ }
set ps2 {> }

# parse argv
while {true} {
    lassign $argv first
    if {![string match {-*} $first]} break
    shift argv 1
    if {$first == "--"} {
        break
    } elseif {$first == "-v"} {
        set debug 1
    } elseif {$first == "-log"} {
        lassign $argv log_file
        shift argv 1
    } elseif {$first == "-junit"} {
        lassign $argv junit_file
        shift argv 1
    } elseif {$first == "-command"} {
        lassign $argv command_line
        shift argv 1
    } elseif {$first == "-ps1"} {
        lassign $argv ps1
        shift argv 1
    } elseif {$first == "-ps2"} {
        lassign $argv ps2
        shift argv 1
    } elseif {$first == "-timeout"} {
        lassign $argv timeout; # timeout variable of Expect
        shift argv 1
    }
}

log_user 0
if {$log_file != ""} {
    log_file -a $log_file
}

set f [open [lindex $argv 0]]
set suite [markdown::parse $f $command_line]
close $f
run_suite $suite

if {$junit_file != ""} {
    write_junit
}
